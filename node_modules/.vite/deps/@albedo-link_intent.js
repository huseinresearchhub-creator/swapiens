import "./chunk-DC5AMYBS.js";

// node_modules/@albedo-link/intent/src/random-token-generator.js
function generateRandomToken() {
  const rn = new Uint32Array(4);
  if (typeof crypto !== "undefined" && crypto.getRandomValues) {
    crypto.getRandomValues(rn);
  } else {
    for (let i = 0; i < rn.length; i++) {
      rn[i] = Math.floor(Math.random() * 4294967295);
    }
  }
  return Array.from(rn).map((n) => n.toString(36)).join("");
}

// node_modules/@albedo-link/intent/src/intent-interface.js
var intentInterface = {
  public_key: {
    risk: "low",
    title: "View public key",
    description: "Requests account public key. It's a simple way of authentication for Stellar-based applications. The response ensures that a user owns the corresponding secret key.",
    unsafe: false,
    implicitFlow: false,
    params: {
      token: {
        description: "Verification token generated by the application (should be unique or random).",
        type: "string",
        required: false
      },
      callback: {
        description: "Optional URL callback where Albedo will POST a signed token and public key.",
        type: "string",
        required: false
      },
      require_existing: {
        description: "Allow existing Albedo accounts only.",
        type: "boolean",
        required: false
      }
    },
    returns: {
      pubkey: {
        description: "User-selected public key.",
        type: "string"
      },
      signed_message: {
        description: "HEX-encoded authentication message derived from the public key and verification token.",
        type: "string"
      },
      signature: {
        description: "HEX-encoded ED25519 signature of the authentication message that can be further used to verify user's keypair ownership.",
        type: "string"
      }
    }
  },
  sign_message: {
    risk: "medium",
    title: "Sign text message",
    description: "Requests arbitrary message signing. Can be used to implement identity/ownership verification.",
    unsafe: false,
    implicitFlow: true,
    params: {
      message: {
        description: "Text message to sign.",
        type: "string",
        required: true
      },
      pubkey: {
        description: "Specific public key requested by the application.",
        type: "string",
        required: false
      },
      callback: {
        description: "Optional URL callback where Albedo will POST a signed message.",
        type: "string",
        required: false
      }
    },
    returns: {
      pubkey: {
        description: "User-selected public key.",
        type: "string"
      },
      original_message: {
        description: "Text message to sign from request.",
        type: "string"
      },
      signed_message: {
        description: "HEX-encoded message derived from the public key and original message.",
        type: "string"
      },
      message_signature: {
        description: "HEX-encoded ED25519 signature of the signed message.",
        type: "string"
      }
    }
  },
  tx: {
    risk: "high",
    title: "Sign transaction",
    description: "Requests a signature for the transaction. Returns the signed transaction envelope that can be submitted to the network or used for multi-sig coordination.",
    unsafe: true,
    implicitFlow: true,
    params: {
      xdr: {
        description: "XDR-encoded transaction envelope to sign.",
        type: "string",
        required: true
      },
      pubkey: {
        description: "Specific public key requested by the application.",
        type: "string",
        required: false
      },
      network: {
        description: "Stellar network identifier.",
        type: "string",
        required: false
      },
      callback: {
        description: "Optional URL callback where Albedo will POST the signed transaction XDR instead of submitting it to Horizon. ",
        type: "string",
        required: false
      },
      submit: {
        description: "If set, the signed transaction will be submitted to the Horizon server instead of returning it to the application.",
        type: "boolean",
        required: false
      }
    },
    returns: {
      xdr: {
        description: "XDR-encoded transaction envelope from request.",
        type: "string"
      },
      tx_hash: {
        description: "HEX-encoded transaction hash.",
        type: "string"
      },
      signed_envelope_xdr: {
        description: "XDR-encoded transaction envelope with new signatures.",
        type: "string"
      },
      network: {
        description: "Stellar network identifier.",
        type: "string"
      },
      result: {
        description: "Optional response from Horizon if the transaction has been submitted automatically.",
        type: "object"
      }
    }
  },
  pay: {
    risk: "high",
    title: "Make payment",
    description: "Requests a payment from a user. Works with any Stellar asset, supports transaction memo.",
    unsafe: false,
    implicitFlow: true,
    params: {
      amount: {
        description: "Requested payment amount.",
        type: "string",
        required: true
      },
      destination: {
        description: "Payment destination address.",
        type: "string",
        required: true
      },
      asset_code: {
        description: "Asset code (skip for XLM).",
        type: "string",
        required: false
      },
      asset_issuer: {
        description: "Asset issuer (skip for XLM).",
        type: "string",
        required: false
      },
      memo: {
        description: "Transaction memo (required for exchanges and some anchors).",
        type: "string",
        required: false
      },
      memo_type: {
        description: "Transaction memo type.",
        type: "string",
        required: false
      },
      pubkey: {
        description: "Specific public key requested by the application.",
        type: "string",
        required: false
      },
      network: {
        description: 'Stellar network identifier ("public" or "testnet").',
        type: "string",
        required: false
      },
      callback: {
        description: "Optional URL callback where Albedo will POST the signed transaction XDR instead of submitting it to Horizon. ",
        type: "string",
        required: false
      },
      submit: {
        description: "If set, the signed transaction will be submitted to the Horizon server instead of returning it to the application.",
        type: "boolean",
        required: false
      }
    },
    returns: {
      amount: {
        description: "Payment amount from request.",
        type: "string"
      },
      destination: {
        description: "Payment destination address from request.",
        type: "string"
      },
      asset_code: {
        description: "Asset code from request.",
        type: "string"
      },
      asset_issuer: {
        description: "Asset issuer from request.",
        type: "string"
      },
      memo: {
        description: "Transaction memo from request.",
        type: "string"
      },
      memo_type: {
        description: "Transaction memo type from request.",
        type: "string"
      },
      tx_hash: {
        description: "HEX-encoded transaction hash.",
        type: "string"
      },
      signed_envelope_xdr: {
        description: "XDR-encoded transaction envelope with new signatures.",
        type: "string"
      },
      pubkey: {
        description: "User-selected public key.",
        type: "string"
      },
      network: {
        description: "Stellar network identifier.",
        type: "string"
      },
      result: {
        description: "Optional response from Horizon if the transaction has been submitted automatically.",
        type: "object"
      }
    }
  },
  trust: {
    risk: "low",
    title: "Establish trustline",
    description: "Requests permission to create a trustline to a given Stellar asset. Gradually simplifies the process of creating trustlines for anchors, ICOs, and airdrops.",
    unsafe: false,
    implicitFlow: true,
    params: {
      asset_code: {
        description: "Trustline asset code.",
        type: "string",
        required: true
      },
      asset_issuer: {
        description: "Trustline asset issuer address.",
        type: "string",
        required: true
      },
      limit: {
        description: "Trust limit.",
        type: "string",
        required: false
      },
      memo: {
        description: "Transaction memo (required for exchanges and some anchors).",
        type: "string",
        required: false
      },
      memo_type: {
        description: "Transaction memo type.",
        type: "string",
        required: false
      },
      pubkey: {
        description: "Specific public key requested by the application.",
        type: "string",
        required: false
      },
      network: {
        description: 'Stellar network identifier ("public" or "testnet").',
        type: "string",
        required: false
      },
      callback: {
        description: "Optional URL callback where Albedo will POST the signed transaction XDR instead of submitting it to Horizon. ",
        type: "string",
        required: false
      },
      submit: {
        description: "If set, the signed transaction will be submitted to the Horizon server instead of returning it to the application.",
        type: "boolean",
        required: false
      }
    },
    returns: {
      asset_code: {
        description: "Trustline asset code from request.",
        type: "string"
      },
      asset_issuer: {
        description: "Trustline asset issuer address from request.",
        type: "string"
      },
      limit: {
        description: "Trust limit from request.",
        type: "string"
      },
      tx_hash: {
        description: "HEX-encoded transaction hash.",
        type: "string"
      },
      signed_envelope_xdr: {
        description: "XDR-encoded transaction envelope with new signatures.",
        type: "string"
      },
      pubkey: {
        description: "User-selected public key.",
        type: "string"
      },
      network: {
        description: "Stellar network identifier.",
        type: "string"
      },
      result: {
        description: "Optional response from Horizon if the transaction has been submitted automatically.",
        type: "object"
      }
    }
  },
  exchange: {
    risk: "high",
    title: "Purchase tokens",
    description: "Requests permission to buy tokens on Stellar DEX at market price.",
    unsafe: true,
    implicitFlow: false,
    params: {
      amount: {
        description: "The amount of asset to buy.",
        type: "string",
        required: true
      },
      max_price: {
        description: "Maximum price the user willing to pay.",
        type: "string",
        required: true
      },
      sell_asset_code: {
        description: "Asset code of the asset to sell.",
        type: "string",
        required: false
      },
      sell_asset_issuer: {
        description: "Issuer account of the asset to sell.",
        type: "string",
        required: false
      },
      buy_asset_code: {
        description: "Asset code of the asset to buy.",
        type: "string",
        required: false
      },
      buy_asset_issuer: {
        description: "Issuer account of the asset to buy.",
        type: "string",
        required: false
      },
      memo: {
        description: "Transaction memo (required for exchanges and some anchors).",
        type: "string",
        required: false
      },
      memo_type: {
        description: "Transaction memo type.",
        type: "string",
        required: false
      },
      pubkey: {
        description: "Specific public key requested by the application.",
        type: "string",
        required: false
      },
      network: {
        description: 'Stellar network identifier ("public" or "testnet").',
        type: "string",
        required: false
      },
      callback: {
        description: "Optional URL callback where Albedo will POST the signed transaction XDR instead of submitting it to Horizon.",
        type: "string",
        required: false
      },
      submit: {
        description: "If set, the signed transaction will be submitted to the Horizon server instead of returning it to the application.",
        type: "boolean",
        required: false
      }
    },
    returns: {
      amount: {
        description: "The amount of asset to buy from request.",
        type: "string"
      },
      max_price: {
        description: "Maximum price the user willing to pay from request.",
        type: "string"
      },
      sell_asset_code: {
        description: "Asset code of the asset to sell from request.",
        type: "string"
      },
      sell_asset_issuer: {
        description: "Issuer account of the asset to sell from request.",
        type: "string"
      },
      buy_asset_code: {
        description: "Asset code of the asset to buy from request.",
        type: "string"
      },
      buy_asset_issuer: {
        description: "Issuer account of the asset to buy from request.",
        type: "string"
      },
      tx_hash: {
        description: "HEX-encoded transaction hash.",
        type: "string"
      },
      signed_envelope_xdr: {
        description: "XDR-encoded transaction envelope with new signatures.",
        type: "string"
      },
      pubkey: {
        description: "User-selected public key.",
        type: "string"
      },
      network: {
        description: "Stellar network identifier.",
        type: "string"
      },
      result: {
        description: "Optional response from Horizon if the transaction has been submitted automatically.",
        type: "object"
      }
    }
  },
  implicit_flow: {
    risk: "high",
    title: "Implicit permissions",
    description: 'Requests temporary access token for one or more intents that can be used to execute actions without explicit confirmation from the user. In order to be executed implicitly, an implicit flow permissions for a given intent should be granted and "pubkey" parameter set.',
    unsafe: true,
    implicitFlow: false,
    params: {
      intents: {
        description: "Requested implicit flow intents.",
        type: "string|string[]",
        required: true
      },
      network: {
        description: 'Stellar network identifier ("public" or "testnet").',
        type: "string",
        required: false
      }
    },
    returns: {
      granted: {
        description: "Whether a user granted permissions or not.",
        type: "boolean"
      },
      intents: {
        description: "Requested implicit flow intents.",
        type: "string[]"
      },
      grants: {
        description: "Implicit flow intents that have been granted.",
        type: "string[]"
      },
      session: {
        description: "Unique implicit session id.",
        type: "string"
      },
      valid_until: {
        description: "Session expiration timestamp.",
        type: "number"
      },
      pubkey: {
        description: "User-selected public key.",
        type: "string"
      },
      network: {
        description: "Stellar network identifier.",
        type: "string"
      }
    }
  },
  manage_account: {
    risk: "low",
    title: "Open account settings",
    description: "Opens account settings window for a given account.",
    unsafe: false,
    implicitFlow: false,
    params: {
      pubkey: {
        description: "Specific public key requested by the application.",
        type: "string",
        required: true
      },
      network: {
        description: 'Stellar network identifier ("public" or "testnet").',
        type: "string",
        required: false
      }
    },
    returns: {
      pubkey: {
        description: "Public key from intent request.",
        type: "string"
      }
    }
  }
};
var intent_interface_default = intentInterface;

// node_modules/@albedo-link/intent/src/intent-errors.js
var intentErrors = {
  unhandledError: {
    message: "Unhandled error occurred. If this error persists, please contact Albedo support.",
    code: -1
  },
  externalError: {
    message: "External error occurred.",
    code: -2
  },
  invalidIntentRequest: {
    message: "Intent request is invalid.",
    code: -3
  },
  actionRejectedByUser: {
    message: "Action request was rejected by the user.",
    code: -4
  },
  horizonError: {
    message: "Transaction failed when submitted to Stellar network.",
    code: -5
  },
  callbackError: {
    message: "Callback redirect failed.",
    code: -6
  }
};
var intent_errors_default = intentErrors;

// node_modules/@albedo-link/intent/package.json
var package_default = {
  name: "@albedo-link/intent",
  version: "0.11.2",
  description: "A lightweight browser wrapper for Albedo API that provides a promise-based interface for all supported intents.",
  author: "StellarExpertTeam<info@stellar.expert>",
  license: "MIT",
  homepage: "https://github.com/stellar-expert/albedo",
  bugs: {
    url: "https://github.com/stellar-expert/albedo/issues",
    email: "info@stellar.expert"
  },
  repository: {
    type: "git",
    url: "https://github.com/stellar-expert/albedo.git"
  },
  scripts: {
    build: "webpack --mode=production --config ./webpack.config.js",
    postbuild: "node build/generate-docs.js",
    test: "mocha"
  },
  main: "./lib/albedo.intent.js",
  module: "./src/index.js",
  types: "./src/index.d.ts",
  keywords: [
    "albedo",
    "stellar",
    "SSO",
    "signer",
    "intent",
    "multi-sig"
  ],
  devDependencies: {
    "@babel/core": "^7.14.5",
    "@babel/plugin-proposal-class-properties": "^7.14.5",
    "@babel/plugin-proposal-object-rest-spread": "^7.14.5",
    "@babel/preset-env": "^7.14.5",
    "@babel/register": "^7.14.5",
    "babel-loader": "^8.2.2",
    chai: "^4.3.4",
    mocha: "^9.0.0",
    sinon: "^11.1.1",
    "terser-webpack-plugin": "^5.1.3",
    webpack: "^5.38.1",
    "webpack-cli": "^4.7.2"
  },
  mocha: {
    recursive: true,
    require: [
      "@babel/register",
      "./test/test-helper.js"
    ],
    ui: "bdd"
  }
};

// node_modules/@albedo-link/intent/src/transport-handler.js
function TransportHandler(targetWindow, ephemeral = false) {
  this.windowHandler = targetWindow;
  this.ephemeral = !!ephemeral;
  this.isLoaded = false;
  this.pendingRequests = {};
  this.preprocessRequestParams = null;
  this.onLoaded = new Promise((resolve, reject) => this.onLoadedCallback = resolve).then(() => this);
  this.messageHandler = this.messageHandler.bind(this);
  window.addEventListener("message", this.messageHandler, false);
}
TransportHandler.prototype = {
  isLoaded: false,
  markLoaded() {
    const { onLoadedCallback } = this;
    if (onLoadedCallback) {
      this.onLoadedCallback = null;
      this.isLoaded = true;
      onLoadedCallback();
    }
  },
  /**
   * Handler for incoming communication messages processing.
   * @param {Object} data - Received data.
   */
  messageHandler({ data }) {
    if (data.albedo) {
      const { version } = data.albedo;
      return this.markLoaded();
    }
    if (data.albedoIntentResult) {
      const { __reqid, ...result } = data.albedoIntentResult, pending = this.pendingRequests[__reqid];
      if (pending) {
        delete this.pendingRequests[__reqid];
        pending(result.error, result);
        if (this.ephemeral) {
          window.removeEventListener("message", this.messageHandler, false);
          this.windowHandler.close();
        }
      }
    }
  },
  /**
   * Handler for the transport window close event.
   */
  transportCloseHandler() {
    for (let key in this.pendingRequests)
      if (this.pendingRequests.hasOwnProperty(key)) {
        const pending = this.pendingRequests[key];
        delete this.pendingRequests[key];
        pending(intent_errors_default.actionRejectedByUser);
      }
  },
  /**
   * Request intent confirmation using current transport.
   * @param {Object} params - Intent request params.
   * @return {Promise}
   */
  postMessage(params) {
    const nonce = generateRandomToken();
    return new Promise((resolve, reject) => {
      this.onLoaded.then(() => {
        this.pendingRequests[nonce] = (err, data) => err ? reject(err) : resolve(data);
        params = Object.assign({ __reqid: nonce, __albedo_intent_version: package_default.version }, params);
        if (this.preprocessRequestParams) {
          params = this.preprocessRequestParams(params);
        }
        this.windowHandler.postMessage(params, "*");
      });
    });
  }
};
var transport_handler_default = TransportHandler;

// node_modules/@albedo-link/intent/src/transport-builder.js
function createDialogTransport(frontendUrl) {
  const url = `${frontendUrl}/confirm`, w = 440, h = 600, dualScreenLeft = window.screenLeft !== void 0 ? window.screenLeft : window.screenX, dualScreenTop = window.screenTop !== void 0 ? window.screenTop : window.screenY, currentWindowWidth = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width, currentWindowHeight = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height, left = currentWindowWidth / 2 - w / 2 + dualScreenLeft, top = currentWindowHeight / 2 - h / 2 + dualScreenTop;
  const dialogWindow = window.open(url, "auth.albedo.link", `height=${h},width=${w},top=${top},left=${left},menubar=0,toolbar=0,location=0,status=0,personalbar=0,scrollbars=0,dependent=1`);
  return new transport_handler_default(dialogWindow, true).onLoaded;
}
var sharedIframeTransport = null;
function createIframeTransport(frontendUrl) {
  if (!sharedIframeTransport) {
    const iframe = document.createElement("iframe");
    iframe.style.border = "none";
    Object.assign(iframe, {
      width: "0",
      height: "0",
      frameBorder: "0",
      referrerPolicy: "origin",
      src: `${frontendUrl}`
    });
    document.body.appendChild(iframe);
    sharedIframeTransport = new transport_handler_default(iframe.contentWindow);
  }
  return sharedIframeTransport.onLoaded;
}

// node_modules/@albedo-link/intent/src/implicit-session.js
function ImplicitSession({ session, pubkey, grants, valid_until }) {
  this.key = session;
  this.pubkey = pubkey;
  this.grants = grants.slice();
  this.validUntil = valid_until;
  Object.freeze(this);
  Object.freeze(this.grants);
}
ImplicitSession.prototype = {
  /**
   * Unique session key.
   * @type {String}
   */
  key: "",
  /**
   * Public key of the key pair used to authorize the session.
   * @type {String}
   */
  pubkey: "",
  /**
   * Granted permissions.
   * @type {Array<String>}
   */
  grants: [],
  /**
   * Time-to-live.
   * @type {Number}
   */
  validUntil: 0,
  /**
   * Check whether the session is expired or not.
   * @return {boolean}
   */
  get isExpired() {
    return this.validUntil - 2e3 < (/* @__PURE__ */ new Date()).getTime();
  },
  toJSON() {
    return {
      session: this.key,
      pubkey: this.pubkey,
      grants: this.grants.slice(),
      valid_until: this.validUntil
    };
  }
};
var implicit_session_default = ImplicitSession;

// node_modules/@albedo-link/intent/src/implicit-session-storage.js
var storagePrefix = "albedo_session_";
var implicitSessions = {};
function getStorage() {
  return window.sessionStorage;
}
var saveToBrowserStorage = true;
function saveImplicitSession(intentResult) {
  const session = new implicit_session_default(intentResult);
  if (!saveToBrowserStorage) {
    implicitSessions[session.pubkey] = session;
  } else {
    getStorage().setItem(storagePrefix + session.pubkey, JSON.stringify(session));
  }
}
function retrieveSessionFromStorage(pubkey) {
  let session;
  if (!saveToBrowserStorage) {
    session = implicitSessions[pubkey];
  } else {
    const restored = getStorage().getItem(storagePrefix + pubkey);
    if (restored) {
      session = new implicit_session_default(JSON.parse(restored));
    }
  }
  if (!session) return null;
  if (session.isExpired) {
    forgetSession(pubkey);
    return null;
  }
  return session;
}
function getImplicitSession(intent, pubkey) {
  const session = retrieveSessionFromStorage(pubkey);
  if (!session || !session.grants.includes(intent)) return null;
  return session;
}
function getAllImplicitSessions() {
  const storage = getStorage();
  return Object.keys(storage).filter((key) => key.indexOf(storagePrefix) === 0).map((key) => retrieveSessionFromStorage(key.substr(storagePrefix.length))).filter((session) => !!session);
}
function forgetSession(pubkey) {
  if (!saveToBrowserStorage) {
    delete implicitSessions[pubkey];
  } else {
    getStorage().removeItem(storagePrefix + pubkey);
  }
}

// node_modules/@albedo-link/intent/src/intent-dispatcher.js
function intentError(msg) {
  return Object.assign(new Error(), intent_errors_default.invalidIntentRequest, { ext: msg });
}
function requestIntentConfirmation(params, frontendUrl) {
  try {
    const { intent } = params;
    if (!intent)
      throw intentError('Parameter "intent" is required.');
    const intentDescriptor = intent_interface_default[intent];
    if (!intentDescriptor)
      throw intentError(`Unknown intent: "${intent}".`);
    const requestParams = prepareRequestParams(intentDescriptor, params);
    return prepareTransport(requestParams, frontendUrl).then((transport) => sendRequest(requestParams, transport));
  } catch (e) {
    const { code = -1, message, ext } = e, res = { message, code };
    if (ext) {
      res.ext = ext;
    }
    return Promise.reject(res);
  }
}
function prepareTransport(params, frontendUrl) {
  if (params.pubkey) {
    const session = getImplicitSession(params.intent, params.pubkey);
    if (session) {
      params.session = session.key;
      return createIframeTransport(frontendUrl);
    }
  }
  setTimeout(() => {
    if (params.intent === "implicit_flow") {
      createIframeTransport(frontendUrl);
    }
  }, 200);
  return createDialogTransport(frontendUrl);
}
function sendRequest(params, transport) {
  return transport.postMessage(params).then((result) => {
    if (result.intent === "implicit_flow" && result.granted) {
      saveImplicitSession(result);
    }
    return result;
  });
}
function prepareRequestParams(intentDescriptor, params) {
  if (typeof params !== "object")
    throw intentError("Intent parameters expected.");
  const { intent, pubkey } = params, requestParams = { intent };
  if (pubkey && !/^G[0-9A-Z]{55}$/.test(pubkey))
    throw intentError('Invalid "pubkey" parameter. Stellar account public key expected.');
  for (const key in intentDescriptor.params) {
    const props = intentDescriptor.params[key], value = params[key];
    if (value) {
      requestParams[key] = value;
    } else if (props.required) {
      throw intentError(`Parameter "${key}" is required for intent "${intent}".`);
    }
  }
  return requestParams;
}

// node_modules/@albedo-link/intent/src/web+stellar-handler.js
function parseQuery(query = null) {
  if (query === null) {
    query = window.location.search;
  }
  if (query[0] === "?") query = query.substr(1);
  const dest = {};
  for (let kv of query.split("&")) {
    const [key, value] = kv.split("=").map((v) => decodeURIComponent(v));
    dest[key] = value;
  }
  return dest;
}
function bindWebStellarLinkHandler(albedoIntent) {
  if (typeof document === "undefined" || !document.addEventListener) return;
  document.addEventListener("click", function sep0007Handler(e) {
    if (e.target.tagName !== "A" || (e.target.href || "").indexOf("web+stellar:") !== 0) return;
    e.preventDefault();
    e.stopImmediatePropagation();
    const { pathname: intentName, search } = new URL(e.target.href);
    if (!["tx", "pay"].includes(intentName)) {
      alert(`Invalid operation requested: ${intentName}. It's likely an external application error. Please contact support team of ${window.location.origin}.`);
      return;
    }
    const params = parseQuery(search);
    albedoIntent.request(intentName, params);
  }, false);
}

// node_modules/@albedo-link/intent/src/index.js
if (typeof window === "object" && typeof window.fetch !== "function") {
  throw new Error("Browser FetchAPI is not available. For legacy browsers support use polyfills such as whatwg-fetch.");
}
function AlbedoIntent() {
}
AlbedoIntent.prototype = {
  frontendUrl: "https://albedo.link",
  intentInterface: intent_interface_default,
  intentErrors: intent_errors_default,
  /**
   * Initiate external intent request.
   * @param {String} intent - Intent name.
   * @param {Object} [params] - Request parameters.
   * @returns {Promise<Object>}
   */
  request(intent, params) {
    return requestIntentConfirmation(Object.assign(params || {}, { intent }), this.frontendUrl);
  },
  /**
   * Requests temporary permissions to execute the specific intents without calling confirmation dialog.
   * @param {Object} params - Intent parameters.
   * @param {Array<String>} params.intents - Requested intents.
   * @returns {Promise<ImplicitFlowIntentResult>}
   */
  implicitFlow(params) {
    return this.request("implicit_flow", params);
  },
  /**
   * Request secure third-party application authentication.
   * @param {Object} params - Intent parameters.
   * @param {String} [params.token] - Verification token generated by the application (should be unique or random).
   * @param {String} [params.require_existing] - Allow existing Albedo accounts only.
   * @returns {Promise<PublicKeyIntentResult>}
   */
  publicKey(params) {
    params = Object.assign({}, params);
    if (!params.token) {
      params.token = generateRandomToken();
    }
    return this.request("public_key", params);
  },
  /**
   * Request transaction signing, returns the signed transaction envelope.
   * @param {Object} params - Intent parameters.
   * @param {String} params.xdr - A Stellar transaction in XDR format encoded in base64.
   * @param {String} [params.pubkey] - Specific public key requested by the application.
   * @param {String} [params.network] - Stellar account network identifier or private network passphrase.
   * @param {Boolean} [params.submit] - If set, the signed transaction will be submitted to the Horizon server instead of returning it to the application.
   * @returns {Promise<TxIntentResult>}
   */
  tx(params) {
    return this.request("tx", params);
  },
  /**
   * Request an asset trustline creation.
   * @param {Object} params - Intent parameters.
   * @param {String} params.destination - Payment destination address.
   * @param {String} params.amount - Amount to pay.
   * @param {String} [params.asset_code] - [Optional] Asset code (if not set XLM is implied).
   * @param {String} [params.asset_issuer] - [Optional] Asset issuer (if not set XLM is implied).
   * @param {String} [params.memo] - [Optional] Memo to be included in the payment.
   * @param {('MEMO_TEXT' | 'MEMO_ID' | 'MEMO_HASH' | 'MEMO_RETURN')} [params.memo_type] - [Optional] Memo type to be included in the payment.
   * @param {String} [params.pubkey] - Specific public key requested by the application.
   * @param {String} [params.network] - Stellar account network identifier or private network passphrase.
   * @param {Boolean} [params.submit] - If set, the signed transaction will be submitted to the Horizon server instead of returning it to the application.
   * @returns {Promise<PayIntentResult>}
   */
  pay(params) {
    return this.request("pay", params);
  },
  /**
   * Request an asset trustline creation.
   * @param {Object} params - Intent parameters.
   * @param {String} params.asset_code - Asset code.
   * @param {String} params.asset_issuer - Asset account issuer.
   * @param {String} [params.limit] - [Optional] Trustline limit.
   * @param {String} [params.pubkey] - Specific public key requested by the application.
   * @param {String} [params.network] - Stellar account network identifier or private network passphrase.
   * @param {Boolean} [params.submit] - If set, the signed transaction will be submitted to the Horizon server instead of returning it to the application.
   * @returns {Promise<TrustIntentResult>}
   */
  trust(params) {
    return this.request("trust", params);
  },
  /**
   * Request token exchange on Stellar DEX.
   * @param {Object} params - Intent parameters.
   * @param {String} params.destination - Payment destination address.
   * @param {String} params.amount - Amount to pay.
   * @param {String} params.max_price - Maximum price to pay.
   * @param {String} [params.sell_asset_code] - [Optional] Selling asset code (if not set XLM is implied).
   * @param {String} [params.sell_asset_issuer] - [Optional] Selling asset issuer (if not set XLM is implied).
   * @param {String} [params.buy_asset_code] - [Optional] Selling asset code (if not set XLM is implied).
   * @param {String} [params.buy_asset_issuer] - [Optional] Selling asset issuer (if not set XLM is implied).
   * @return {Promise<ExchangeIntentResult>}
   */
  exchange(params) {
    return this.request("exchange", params);
  },
  /**
   * Request arbitrary data signing.
   * @param {Object} params - Intent parameters.
   * @param {String} params.message - Text message to sign.
   * @param {String} [params.pubkey] - Specific public key requested by the application.
   * @returns {Promise<SignMessageIntentResult>}
   */
  signMessage(params) {
    params = Object.assign({}, params, { message: normalizeMessageToSign(params.message) });
    return this.request("sign_message", params);
  },
  /**
   * Open account settings window for a given account.
   * @param {Object} params - Intent parameters.
   * @param {String} params.pubkey - Specific public key requested by the application.
   * @param {String} [params.network] - Stellar account network identifier or private network passphrase.
   * @returns {Promise<ManageAccountIntentResult>}
   */
  manageAccount(params) {
    return this.request("manage_account", params);
  },
  generateRandomToken() {
    return generateRandomToken();
  },
  /**
   * Check whether an implicit session exists for a given intent and pubkey.
   * @param {String} intent
   * @param {String} pubkey
   * @return {boolean}
   */
  isImplicitSessionAllowed(intent, pubkey) {
    return !!getImplicitSession(intent, pubkey);
  },
  /**
   * Enumerate all currently active implicit sessions.
   * @returns {Array<{pubkey: String, session: String, valid_until: Number, grants: Array<String>}>}
   */
  listImplicitSessions() {
    return getAllImplicitSessions();
  },
  /**
   * Revoke session permission granted for an account.
   * @param {String} pubkey
   */
  forgetImplicitSession(pubkey) {
    forgetSession(pubkey);
  }
};
function normalizeMessageToSign(message) {
  switch (typeof message) {
    case "string":
      return message;
    case "undefined":
      return "";
  }
  return JSON.stringify(message);
}
var albedo = new AlbedoIntent();
albedo.default = albedo;
bindWebStellarLinkHandler(albedo);
var src_default = albedo;
export {
  src_default as default,
  intent_errors_default as intentErrors,
  intent_interface_default as intentInterface
};
//# sourceMappingURL=@albedo-link_intent.js.map
